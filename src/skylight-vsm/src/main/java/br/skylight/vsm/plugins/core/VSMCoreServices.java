package br.skylight.vsm.plugins.core;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.logging.Logger;

import br.skylight.commons.CUCSControl;
import br.skylight.commons.LOI;
import br.skylight.commons.Payload;
import br.skylight.commons.StringHelper;
import br.skylight.commons.Vehicle;
import br.skylight.commons.dli.BitmappedLOI;
import br.skylight.commons.dli.enums.ControlledStationMode;
import br.skylight.commons.dli.enums.ControlledStationModeResponse;
import br.skylight.commons.dli.enums.MessageSource;
import br.skylight.commons.dli.payload.MessageTargetedToStation;
import br.skylight.commons.dli.payload.PayloadConfigurationMessage;
import br.skylight.commons.dli.services.Message;
import br.skylight.commons.dli.services.MessageListener;
import br.skylight.commons.dli.services.MessageType;
import br.skylight.commons.dli.services.MessagingService;
import br.skylight.commons.dli.systemid.CUCSAuthorisationRequest;
import br.skylight.commons.dli.systemid.MessageWithVsmID;
import br.skylight.commons.dli.systemid.VSMAuthorisationResponse;
import br.skylight.commons.dli.systemid.VehicleID;
import br.skylight.commons.infra.IOHelper;
import br.skylight.commons.infra.ThreadWorker;
import br.skylight.commons.plugin.PluginManager;
import br.skylight.commons.plugin.annotations.ExtensionPointsInjection;
import br.skylight.commons.plugin.annotations.ServiceDefinition;
import br.skylight.commons.plugin.annotations.ServiceImplementation;
import br.skylight.commons.plugin.annotations.ServiceInjection;
import br.skylight.commons.services.StorageService;
import br.skylight.vsm.VSMVehicle;
import br.skylight.vsm.plugins.gps.GPSService;

@ServiceDefinition
@ServiceImplementation(serviceDefinition = VSMCoreServices.class)
public class VSMCoreServices extends ThreadWorker implements MessageListener {

	private static final Logger logger = Logger.getLogger(VSMCoreServices.class.getName());

	private Map<Integer, VSMVehicle> vehicles = new HashMap<Integer, VSMVehicle>();// vehicleID

	@ServiceInjection
	public MessagingService messagingService;
	@ServiceInjection
	public VSMConfigurationService cs;
	@ServiceInjection
	public GPSService gpsServices;
	@ServiceInjection
	public StorageService storageService;
	@ServiceInjection
	public PluginManager pluginManager;
	@ExtensionPointsInjection
	public List<VSMVehicleExtensionPoint> vehicleExtensionPoints;

	public VSMCoreServices() {
		super(0.5F);
	}

	@Override
	public void onActivate() throws Exception {
		pluginManager.executeAfterStartup(new Runnable() {
			public void run() {
				// load all vsm vehicles extensions
				for (VSMVehicleExtensionPoint vp : vehicleExtensionPoints) {
					File f = storageService.getFile("vsm-vehicles", getVehicleFileName(vp.getVehicleId()));
					VSMVehicle v = null;
					try {
						v = IOHelper.readStateFromFile(f, vp.getVSMVehicleClass());
					} catch (Exception e) {
						logger.warning("There was a problem loading vsm vehicle extensions. e=" + e.toString());
						e.printStackTrace();
					}
					// no previous state found. create new instance
					if (v == null) {
						try {
							v = vp.getVSMVehicleClass().newInstance();
						} catch (Exception e) {
							logger.warning("There was a problem loading vsm vehicle extensions. e=" + e.toString());
							e.printStackTrace();
						}
					}
					pluginManager.manageObject(v);
					registerVehicle(v);
				}
			}
		});

		// set itself as listener for all message types that may be generated by
		// a CUCS
		for (MessageType mt : MessageType.values()) {
			if (mt.getSource().equals(MessageSource.CUCS) || mt.getSource().equals(MessageSource.CUCS_VSM)) {
				messagingService.setMessageListener(mt, this);
			}
		}
	}

	@Override
	public void onDeactivate() throws Exception {
		// save vsm vehicle's state (to keep current grants etc)
		for (VSMVehicle vv : vehicles.values()) {
			saveVSMVehicle(vv);
		}
	}

	@Override
	// INCOMING MESSAGES FROM CUCS
	public void onMessageReceived(Message message) {
		System.out.println("RECEIVED MESSAGE FROM CUCS");
		try {
			VSMVehicle targetVehicle = vehicles.get(message.getVehicleID());

			// SHOULD THIS MESSAGE BE RECEIVED BY THIS VSM?
			// verify if this message was addressed to this VSM
			if (message instanceof MessageWithVsmID) {
				int messageVsmId = ((MessageWithVsmID) message).getVsmID();
				if (messageVsmId != Message.BROADCAST_ID && messageVsmId != cs.getVsmId()) {
					return;
				}

				// verify if this message is related to a known vehicle ID
			} else if (targetVehicle == null) {
				logger.fine("Received a message addressed to an unregistered vehicle " + StringHelper.formatId(message.getVehicleID()));
				return;
			}

			// ANSWER TO CONTROL REQUESTS
			if (message instanceof CUCSAuthorisationRequest) {
				CUCSAuthorisationRequest r = (CUCSAuthorisationRequest) message;

				// cucs is asking for known vehicles. send info about all
				// vehicles/payloads related to this VSM
				if (r.getVehicleID() == Message.BROADCAST_ID) {
					for (VSMVehicle vehicle : vehicles.values()) {

						// send vehicle authorization/grant status info
						BitmappedLOI authorizedLOIs = vehicle.getVehicle().resolveCUCSControl(message.getCucsID()).getAuthorizedLOIs();

						VSMAuthorisationResponse ar = messagingService.resolveMessageForSending(VSMAuthorisationResponse.class);
						ar.setCucsID(message.getCucsID());
						ar.setVehicleID(vehicle.getVehicle().getVehicleID().getVehicleID());
						ar.getLoiAuthorized().setData(authorizedLOIs.getData());
						ar.getLoiGranted().setData(vehicle.getVehicle().resolveCUCSControl(message.getCucsID()).getGrantedLOIs().getData());
						ar.setVehicleType(vehicle.getVehicle().getVehicleID().getVehicleType());
						ar.setVehicleSubtype(vehicle.getVehicle().getVehicleID().getVehicleSubtype());
						if (ar.getLoiGranted().getLOIs().size() > 0) {
							ar.setControlledStationMode(ControlledStationModeResponse.IN_CONTROL);
						} else {
							ar.setControlledStationMode(ControlledStationModeResponse.NOT_IN_CONTROL);
						}
						messagingService.sendMessage(ar);

						// send vehicle id
						VehicleID v = messagingService.resolveMessageForSending(VehicleID.class);
						v.copyFrom(vehicle.getVehicle().getVehicleID());
						v.setVehicleID(vehicle.getVehicle().getVehicleID().getVehicleID());
						v.setCucsID(message.getCucsID());
						messagingService.sendMessage(v);

						// send payload authorization/grant info
						for (Payload p : vehicle.getVehicle().getPayloads().values()) {
							authorizedLOIs = p.resolveCUCSControl(message.getCucsID()).getAuthorizedLOIs();

							// send payload authorization/grant status info
							ar = messagingService.resolveMessageForSending(VSMAuthorisationResponse.class);
							ar.setCucsID(message.getCucsID());
							ar.setVehicleID(vehicle.getVehicle().getVehicleID().getVehicleID());
							ar.getControlledStation().setUniqueStationNumber(p.getUniqueStationNumber());
							ar.getLoiAuthorized().setData(authorizedLOIs.getData());
							ar.getLoiGranted().setData(p.resolveCUCSControl(message.getCucsID()).getGrantedLOIs().getData());
							ar.setVehicleType(vehicle.getVehicle().getVehicleID().getVehicleType());
							ar.setVehicleSubtype(vehicle.getVehicle().getVehicleID().getVehicleSubtype());
							if (ar.getLoiGranted().getLOIs().size() > 0) {
								ar.setControlledStationMode(ControlledStationModeResponse.IN_CONTROL);
							} else {
								ar.setControlledStationMode(ControlledStationModeResponse.NOT_IN_CONTROL);
							}
							messagingService.sendMessage(ar);

							// send payload configuration details
							PayloadConfigurationMessage pc = messagingService.resolveMessageForSending(PayloadConfigurationMessage.class);
							pc.setNumberOfPayloadRecordingDevices(p.getNumberOfPayloadRecordingDevices());
							pc.setPayloadType(p.getPayloadType());
							pc.setStationDoor(p.getStationDoor());
							pc.getStationNumber().setUniqueStationNumber(p.getUniqueStationNumber());
							pc.setVehicleID(vehicle.getVehicle().getVehicleID().getVehicleID());
							pc.setCucsID(message.getCucsID());
							messagingService.sendMessage(pc);
						}
					}

					// verify if source cucs could be granted with requested LOI
					// to vehicle/payload
				} else {

					// grant/deny control to vehicle
					if (r.getControlledStation().getData() == 0) {
						BitmappedLOI authorizedLOIs = targetVehicle.getVehicle().resolveCUCSControl(message.getCucsID()).getAuthorizedLOIs();
						BitmappedLOI authorizedOverrideLOIs = targetVehicle.getVehicle().resolveCUCSControl(message.getCucsID()).getAuthorizedOverrideLOIs();
						BitmappedLOI grantedLOIs = targetVehicle.getVehicle().resolveCUCSControl(message.getCucsID()).getGrantedLOIs();
						grantOrDenyRequest(r, targetVehicle, authorizedLOIs, authorizedOverrideLOIs, grantedLOIs, 0);

						// grant/deny control to payloads
					} else {
						for (int stationNumber : targetVehicle.getVehicle().getPayloads().keySet()) {
							BitmappedLOI authorizedLOIs = targetVehicle.getVehicle().getPayloads().get(stationNumber).resolveCUCSControl(message.getCucsID()).getAuthorizedLOIs();
							BitmappedLOI authorizedOverrideLOIs = targetVehicle.getVehicle().getPayloads().get(stationNumber).resolveCUCSControl(message.getCucsID()).getAuthorizedOverrideLOIs();
							BitmappedLOI grantedLOIs = targetVehicle.getVehicle().getPayloads().get(stationNumber).resolveCUCSControl(message.getCucsID()).getGrantedLOIs();
							grantOrDenyRequest(r, targetVehicle, authorizedLOIs, authorizedOverrideLOIs, grantedLOIs, stationNumber);
						}
					}

					// save current vehicles control state
					saveVSMVehicle(targetVehicle);
				}

				// RELAY MESSAGE TO VEHICLE
			} else {
				if (targetVehicle != null) {

					if (!cs.isAssertGrantsForRelayingMessages()) {
						targetVehicle.sendMessageToVehicle(message);

					} else {
						// send messages from station to vehicle
						// cucsID must be granted control over payload at
						// specific LOI
						if (message instanceof MessageTargetedToStation) {
							MessageTargetedToStation m = (MessageTargetedToStation) message;

							// verify if all targeted stations on message have
							// the required level of LOI by the sending CUCS
							boolean hasRequiredGrants = true;
							for (Payload p : targetVehicle.getVehicle().getPayloads().values()) {
								if (m.getTargetStations().getStations().contains((int) p.getUniqueStationNumber())) {
									if (!message.getMessageType().getLOIs().matchAny(p.resolveCUCSControl(message.getCucsID()).getGrantedLOIs())) {
										hasRequiredGrants = false;
									}
								}
							}
							if (hasRequiredGrants) {
								targetVehicle.sendMessageToVehicle(message);
							} else {
								logger.info("Cucs hasn't required grants to send messages to all station numbers in message. cucs=" + StringHelper.formatId(message.getCucsID()) + "; vehicleid=" + StringHelper.formatId(message.getVehicleID()));
							}

							// send messages from station to vehicles
							// cucsID must be granted control over payload at
							// specific LOI
						} else {
							BitmappedLOI grantedLOIs = targetVehicle.getVehicle().resolveCUCSControl(message.getCucsID()).getGrantedLOIs();
							if (message.getMessageType().getLOIs().matchAny(grantedLOIs)) {
								targetVehicle.sendMessageToVehicle(message);
							} else {
								logger.info("Cucs hasn't required grants to send messages to vehicle. cucs=" + StringHelper.formatId(message.getCucsID()) + "; vehicleid=" + StringHelper.formatId(message.getVehicleID()));
							}
						}
					}
				} else {
					logger.info("Ignoring message for an unknown vehicle. id=" + StringHelper.formatId(message.getVehicleID()));
				}
			}
		} catch (IOException e) {
			logger.throwing(null, null, e);
		}
	}

	private void saveVSMVehicle(VSMVehicle v) throws IOException {
		File f = storageService.resolveFile("vsm-vehicles", getVehicleFileName(v.getVehicle().getVehicleID().getVehicleID()));
		IOHelper.writeStateToFile(v, f);
	}

	private void grantOrDenyRequest(CUCSAuthorisationRequest r, VSMVehicle v, BitmappedLOI authorizedLOIs, BitmappedLOI authorizedOverrideLOIs, BitmappedLOI grantedLOIs, int stationNumber) throws IOException {
		// PERFORM VEHICLE GRANTING
		// verify if CUCS is authorized on required LOI
		for (LOI loi : r.getRequestedHandoverLOI().getLOIs()) {

			// REQUEST CONTROL
			if (r.getControlledStationMode().equals(ControlledStationMode.REQUEST_CONTROL)) {
				if (authorizedLOIs.isLOI(loi)) {
					boolean thereIsAnotherInOverride = false;
					for (Entry<Integer, CUCSControl> ov : v.getVehicle().getCucsControls().entrySet()) {
						if (ov.getValue().isOverrideMode() && ov.getKey() != r.getCucsID()) {
							thereIsAnotherInOverride = true;
							break;
						}
					}
					// if another CUCs is in override mode and this request
					// isn't override, deny this request
					if (!thereIsAnotherInOverride) {
						// grant control
						grantedLOIs.setLOI(loi.getNumber(), true);
						checkVehicleConnected(v);
					} else {
						logger.info("CUCS " + StringHelper.formatId(r.getCucsID()) + " cannot control vehicle " + StringHelper.formatId(r.getVehicleID()) + " stations " + Arrays.deepToString(r.getControlledStation().getStations().toArray()) + " at LOIs " + Arrays.deepToString(r.getRequestedHandoverLOI().getLOIs().toArray()) + " because another CUCS is in override mode");
					}
				} else {
					logger.info("CUCS " + StringHelper.formatId(r.getCucsID()) + " not authorized to control vehicle " + StringHelper.formatId(r.getVehicleID()) + " stations " + Arrays.deepToString(r.getControlledStation().getStations().toArray()) + " at LOIs " + Arrays.deepToString(r.getRequestedHandoverLOI().getLOIs().toArray()));
				}

				// OVERRIDE CONTROL
			} else if (r.getControlledStationMode().equals(ControlledStationMode.OVERRIDE_CONTROL)) {
				if (authorizedOverrideLOIs.isLOI(loi)) {
					for (Entry<Integer, CUCSControl> ov : v.getVehicle().getCucsControls().entrySet()) {
						// deny control to everyone that isn't in override mode
						if (ov.getKey() != r.getCucsID()) {
							if (!ov.getValue().isOverrideMode()) {
								ov.getValue().getGrantedLOIs().setLOI(loi.getNumber(), false);
								sendControlResponseMessage(ov.getKey(), v.getVehicle(), stationNumber, authorizedLOIs, ov.getValue().getGrantedLOIs());
							}
						}
					}
					// grant control
					grantedLOIs.setLOI(loi.getNumber(), true);
					checkVehicleConnected(v);
				} else {
					logger.info("CUCS " + StringHelper.formatId(r.getCucsID()) + " not authorized to override control of vehicle " + StringHelper.formatId(r.getVehicleID()) + " stations " + Arrays.deepToString(r.getControlledStation().getStations().toArray()) + " at LOIs " + Arrays.deepToString(r.getRequestedHandoverLOI().getLOIs().toArray()));
				}

				// RELINQUISH/HANDOVER CONTROL
			} else if (r.getControlledStationMode().equals(ControlledStationMode.RELINQUISH_CONTROL)) {
				grantedLOIs.setLOI(loi.getNumber(), false);
			}

			// SEND CONTROL STATUS TO CUCS
			sendControlResponseMessage(r.getCucsID(), v.getVehicle(), stationNumber, authorizedLOIs, grantedLOIs);
		}

	}

	private void checkVehicleConnected(VSMVehicle vehicle) {
		if (!vehicle.isConnected()) {
			logger.info("Vehicle " + StringHelper.formatId(vehicle.getVehicle().getVehicleID().getVehicleID()) + " not activated. Activating now...");
			try {
				vehicle.connect();
			} catch (Exception e) {
				logger.severe("Failed to load vehicle " + StringHelper.formatId(vehicle.getVehicle().getVehicleID().getVehicleID()) + ". CUCS won't have any response over controls for this vehicle. e=" + e);
				logger.throwing(null, null, e);
				e.printStackTrace();
			}
		}
	}

	private void sendControlResponseMessage(int cucsID, Vehicle vehicle, int stationNumber, BitmappedLOI authorizedLOIs, BitmappedLOI grantedLOIs) throws IOException {
		VSMAuthorisationResponse r = messagingService.resolveMessageForSending(VSMAuthorisationResponse.class);
		r.setCucsID(cucsID);
		r.setVehicleID(vehicle.getVehicleID().getVehicleID());
		r.setVehicleType(vehicle.getVehicleID().getVehicleType());
		r.setVehicleSubtype(vehicle.getVehicleID().getVehicleSubtype());
		r.getControlledStation().addStation(stationNumber);
		r.getLoiAuthorized().setData(authorizedLOIs.getData());
		r.getLoiGranted().setData(grantedLOIs.getData());
		if (grantedLOIs.getLOIs().size() > 0) {
			r.setControlledStationMode(ControlledStationModeResponse.IN_CONTROL);
		} else {
			r.setControlledStationMode(ControlledStationModeResponse.NOT_IN_CONTROL);
		}
		messagingService.sendMessage(r);
	}

	public void registerVehicle(final VSMVehicle vehicle) {
		vehicles.put(vehicle.getVehicle().getVehicleID().getVehicleID(), vehicle);

		vehicle.setMessageListener(new MessageListener() {
			// TRANSFER INCOMING MESSAGES FROM VEHICLE TO CUCS
			public void onMessageReceived(Message message) {
				// forward messages to cucs that matches required LOI for
				// vehicle/payload
				// vehicle specific message
				if (!(message instanceof MessageTargetedToStation)) {
					for (Entry<Integer, CUCSControl> cc : vehicle.getVehicle().getCucsControls().entrySet()) {
						if (cc.getValue().getGrantedLOIs().matchAny(message.getMessageType().getLOIs())) {
							if (message.getCucsID() == Message.BROADCAST_ID) {
								message.setCucsID(cc.getKey());
							}
							messagingService.sendMessage(message);
						}
					}

					// payload specific message
				} else {
					MessageTargetedToStation m = (MessageTargetedToStation) message;
					for (Integer uniqueStationNumber : m.getTargetStations().getStations()) {
						Payload p = vehicle.getVehicle().getPayloads().get(uniqueStationNumber);
						for (Entry<Integer, CUCSControl> cc : p.getCucsControls().entrySet()) {
							if (cc.getValue().getGrantedLOIs().matchAny(message.getMessageType().getLOIs())) {
								if (message.getCucsID() == Message.BROADCAST_ID) {
									message.setCucsID(cc.getKey());
								}
								messagingService.sendMessage(message);
							}
						}
					}
				}
			}
		});
		checkVehicleConnected(vehicle);
	}

	@Override
	public void step() throws Exception {
		// send differential GPS signal
		for (VSMVehicle v : vehicles.values()) {
			if (v.isSupportsDifferentialGPSSignal()) {
				// TODO implement this
			}
		}
	}

	public Map<Integer, VSMVehicle> getVehicles() {
		return vehicles;
	}

	private String getVehicleFileName(int vehicleID) {
		return "vsmvehicle-" + StringHelper.formatId(vehicleID).replaceAll(":", "") + ".dat";
	}

}
